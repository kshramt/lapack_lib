<%-
   require 'lapack_lib_util'
-%>

#include "lapack_lib.h"
module lapack_lib
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
   USE_LAPACK_LIB_H
   use, intrinsic:: iso_fortran_env, only: INPUT_UNIT, OUTPUT_UNIT, ERROR_UNIT
   use, non_intrinsic:: lapack_constant_lib, only: SIZE_KIND, ONE
   use, non_intrinsic:: lapack_interface_lib, only: sgemm, dgemm, cgemm, zgemm
   use, non_intrinsic:: lapack_interface_lib, only: sgemv, dgemv, cgemv, zgemv
   use, non_intrinsic:: lapack_interface_lib, only: sdot, ddot, cdotc, zdotc

   implicit none

   private
   ! If you use LAPACK/BLAS with `ilp64` without `-fdefault-integer-8`, you should set `SIZE_KIND = INT64`
   public:: SIZE_KIND
   public:: ONE
   public:: mul, mul_

   <%- TYPES.each{|a, b| -%>
      interface mul
         module procedure mul<%= a %><%= b %>
      end interface mul

      interface mul_
         module procedure mul_<%= a %><%= b %>
      end interface mul_
   <%- } -%>

contains


   <%- (LOGICAL2S_LOGICAL2S + NUM2S_NUM2S).each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret, transa, transb)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         Character(len=1), intent(in), optional:: transa, transb
         Character(len=len(transa)):: transa_
         Character(len=len(transb)):: transb_

         if(present(transa))then
            transa_ = transa
         else
            transa_ = 'n'
         end if
         if(present(transb))then
            transb_ = transb
         else
            transb_ = 'n'
         end if

         <%= set_sizes(a, b) %>
         <%- ta = a.type; tb = b.type; ka = a.kind; kb = b.kind -%>
         <%- if ta == tb and (ta == :Logical or ta == :Integer) -%>
            select case(transa_)
            <%- ['n', 't', 'c'].each{|transa| -%>
               <%- if transa != 'c' or (transa == 'c' and ta == :Complex ) -%>
                  case('<%= transa %>', '<%= transa.upcase %>')
                     select case(transb_)
                     <%- ['n', 't', 'c'].each{|transb| -%>
                        <%- if transb != 'c' or (transb == 'c' and tb == :Complex ) -%>
                           case('<%= transb %>', '<%= transb.upcase %>')
                              ret = matmul(<%= ntc(transa, 'a') %>, <%= ntc(transb, 'b') %>)
                        <%- end -%>
                     <%- } -%>
                     case default
                        write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transb`: ', trim(transb_)
                        error stop
                     end select
               <%- end -%>
            <%- } -%>
            case default
               write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transa`: ', trim(transa_)
               error stop
            end select
         <%- elsif ta == tb and ka == kb -%>
            if(transa_ == 'n' .or. transa_ == 'n')then
               if(transb_ == 'n' .or. transb_ == 'N')then
                  ASSERT(n_a_2 == n_b_1)
               else
                  ASSERT(n_a_2 == n_b_2)
               end if
            else
               if(transb_ == 'n' .or. transb_ == 'N')then
                  ASSERT(n_a_1 == n_b_1)
               else
                  ASSERT(n_a_1 == n_b_2)
               end if
            end if
            <%- if ta == :Real and ka == :REAL32 -%>
               call sgemm('n', 'n', n_a_1, n_b_2, n_a_2, real(1, kind=kind(ret)), a, n_a_1, b, n_b_1, real(1, kind=kind(ret)), ret, n_a_1)
            <%- elsif ta == :Real and ka == :REAL64 -%>
               call dgemm('n', 'n', n_a_1, n_b_2, n_a_2, real(1, kind=kind(ret)), a, n_a_1, b, n_b_1, real(1, kind=kind(ret)), ret, n_a_1)
            <%- elsif ta == :Complex and ka == :REAL32 -%>
               call cgemm('n', 'n', n_a_1, n_b_2, n_a_2, cmplx(1, kind=kind(ret)), a, n_a_1, b, n_b_1, cmplx(1, kind=kind(ret)), ret, n_a_1)
            <%- elsif ta == :Complex and ka == :REAL64 -%>
               call zgemm('n', 'n', n_a_1, n_b_2, n_a_2, cmplx(1, kind=kind(ret)), a, n_a_1, b, n_b_1, cmplx(1, kind=kind(ret)), ret, n_a_1)
            <%- else -%>
               select case(transa_)
               <%- ['n', 't', 'c'].each{|transa| -%>
                  <%- if transa != 'c' or (transa == 'c' and ta == :Complex ) -%>
                     case('<%= transa %>', '<%= transa.upcase %>')
                        select case(transb_)
                        <%- ['n', 't', 'c'].each{|transb| -%>
                           <%- if transb != 'c' or (transb == 'c' and tb == :Complex ) -%>
                              case('<%= transb %>', '<%= transb.upcase %>')
                                 ret = matmul(<%= ntc(transa, 'a') %>, <%= ntc(transb, 'b') %>)
                           <%- end -%>
                        <%- } -%>
                        case default
                           write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transb`: ', trim(transb_)
                           error stop
                        end select
                  <%- end -%>
               <%- } -%>
               case default
                  write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transa`: ', trim(transa_)
                  error stop
               end select
            <%- end -%>
         <%- else -%>
            <%- t, k = promote(a, b) -%>
            call mul_(<%= converter(t) %>(a, kind=<%= k %>), <%= converter(t) %>(b, kind=<%= k %>), ret)
         <%- end -%>
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   <%- (LOGICAL2S_LOGICAL1S + NUM2S_NUM1S).each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret, transa)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         Character(len=1), intent(in), optional:: transa
         Character(len=len(transa)):: transa_

         if(present(transa))then
            transa_ = transa
         else
            transa_ = 'n'
         end if

         <%= set_sizes(a, b) %>
         <%- ta = a.type; tb = b.type; ka = a.kind; kb = b.kind -%>
         <%- if ta == tb and (ta == :Logical or ta == :Integer) -%>
            select case(transa_)
            case('n', 'N')
               ret = matmul(a, b)
            case('t', 'T')
               ret = matmul(transpose(a), b)
            <%- if b.type == :Complex -%>
               case('c', 'C')
                  ret = matmul(transpose(conjg(a)), b)
            <%- end -%>
            case default
               write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transa`: ', trim(transa_)
               error stop
            end select
         <%- elsif ta == tb and ka == kb -%>
            if(transa_ == 'n' .or. transa_ == 'N')then
               ASSERT(n_a_2 == n_b_1)
            else
               ASSERT(n_a_1 == n_b_1)
            end if
            <%- if ta == :Real and ka == :REAL32 -%>
               call sgemv(transa_, n_a_1, n_a_2, real(1, kind=kind(ret)), a, n_a_1, b, ONE, real(0, kind=kind(ret)), ret, ONE)
            <%- elsif ta == :Real and ka == :REAL64 -%>
               call dgemv(transa_, n_a_1, n_a_2, real(1, kind=kind(ret)), a, n_a_1, a, ONE, real(0, kind=kind(ret)), ret, ONE)
            <%- elsif ta == :Complex and ka == :REAL32 -%>
               call cgemv(transa_, n_a_1, n_a_2, cmplx(1, kind=kind(ret)), a, n_a_1, a, ONE, cmplx(0, kind=kind(ret)), ret, ONE)
            <%- elsif ta == :Complex and ka == :REAL64 -%>
               call zgemv(transa_, n_a_1, n_a_2, cmplx(1, kind=kind(ret)), a, n_a_1, a, ONE, cmplx(0, kind=kind(ret)), ret, ONE)
            <%- else -%>
               select case(transa_)
               case('n', 'N')
                  ret = matmul(a, b)
               case('t', 'T')
                  ret = matmul(transpose(a), b)
               <%- if b.type == :Complex -%>
                  case('c', 'C')
                     ret = matmul(transpose(conjg(a)), b)
               <%- end -%>
               case default
                  write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transa`: ', trim(transa_)
                  error stop
               end select
            <%- end -%>
         <%- else -%>
            <%- t, k = promote(a, b) -%>
            call mul_(<%= converter(t) %>(a, kind=<%= k %>), <%= converter(t) %>(b, kind=<%= k %>), ret, transa_)
         <%- end -%>
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   <%- (LOGICAL1S_LOGICAL2S + NUM1S_NUM2S).each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret, transb)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         Character(len=1), intent(in), optional:: transb
         Character(len=len(transb)):: transb_

         if(present(transb))then
            transb_ = transb
         else
            transb_ = 'n'
         end if

         select case(transb_)
         case('n', 'N')
            call mul_(b, a, ret, 't')
         case('t', 'T')
            call mul_(b, a, ret, 'n')
         <%- if b.type == :Complex -%>
            case('c', 'C')
               call mul_(conjg(b), a, ret, 'n')
         <%- end -%>
         case default
            write(ERROR_UNIT, *) WHERE_AM_I, 'Unsupported `transb`: ', trim(transb_)
            error stop
         end select
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   <%- (NUM1S_NUM1S + LOGICAL1S_LOGICAL1S).each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret

         <%= set_sizes(a, b) %>
         <%- ta = a.type; tb = b.type; ka = a.kind; kb = b.kind -%>
         <%- if ta == tb and (ta == :Logical or ta == :Integer) -%>
            ret = dot_product(a, b)
         <%- elsif ta == tb and ka == kb -%>
            <%- if ta == :Real and ka == :REAL32 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = sdot(n_a_1, a, ONE, b, ONE)
            <%- elsif ta == :Real and ka == :REAL64 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = ddot(n_a_1, a, ONE, b, ONE)
            <%- elsif ta == :Complex and ka == :REAL32 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = cdotc(n_a_1, a, ONE, b, ONE)
            <%- elsif ta == :Complex and ka == :REAL64 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = zdotc(n_a_1, a, ONE, b, ONE)
            <%- else -%>
               ret = dot_product(a, b)
            <%- end -%>
         <%- else -%>
            <%- t, k = promote(a, b) -%>
            call mul_(<%= converter(t) %>(a, kind=<%= k %>), <%= converter(t) %>(b, kind=<%= k %>), ret)
         <%- end -%>
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   ! scalar to scalar multiplications and `Logical` multiplications were implemented only for consistency
   ! compiler's implementation of scalar to vector/matrix multiplications might be fine
   ! scalar to vector: `*scal`
   ! scalar to matrix: ?

   <%- (NUM0S_NUM0S + NUM0S_NUM12S + NUM12S_NUM0S).each{|a, b| -%>
      pure subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a*b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   <%- (LOGICAL0S_LOGICAL0S + LOGICAL0S_LOGICAL12S + LOGICAL12S_LOGICAL0S).each{|a, b| -%>
      pure subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a.and.b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   ! `mul<T><U>`

   <%- TYPES.each{|a, b| -%>
      function mul<%= a %><%= b %>(a, b) result(ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>:: ret

         call mul_(a, b, ret)
      end function mul<%= a %><%= b %>
   <%- } -%>
end module lapack_lib
