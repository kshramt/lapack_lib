<%-
   require 'lapack_lib_util'
-%>

#include "lapack_lib.h"
module lapack_lib
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
   USE_LAPACK_LIB_H
   use, intrinsic:: iso_fortran_env, only: INPUT_UNIT, OUTPUT_UNIT, ERROR_UNIT
   use, non_intrinsic:: lapack_constant_lib, only: SIZE_KIND, ONE
   use, non_intrinsic:: lapack_interface_lib, only: sdot, ddot, cdotc, zdotc

   implicit none

   private
   ! If you use LAPACK/BLAS with `ilp64` without `-fdefault-integer-8`, you should set `SIZE_KIND = INT64`
   public:: SIZE_KIND
   public:: ONE
   public:: mul, mul_

   <%- TYPES.each{|a, b| -%>
      interface mul
         module procedure mul<%= a %><%= b %>
      end interface mul

      interface mul_
         module procedure mul_<%= a %><%= b %>
      end interface mul_
   <%- } -%>

contains


   <%- MAT_VEC_OR_MAT.each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         ret = matmul(a, b)
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   <%- VEC_VEC.each{|a, b| -%>
      recursive subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret

         <%= set_sizes(a, b) %>
         <%- ta = a.type; tb = b.type; ka = a.kind; kb = b.kind -%>
         <%- if ta == tb and (ta == :Logical or ta == :Integer) -%>
            ret = dot_product(a, b)
         <%- elsif a == b -%>
            <%- if ta == :Real and ka == :REAL32 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = sdot(n_a_1, a, ONE, b, ONE)
            <%- elsif ta == :Real and ka == :REAL64 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = ddot(n_a_1, a, ONE, b, ONE)
            <%- elsif ta == :Complex and ka == :REAL32 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = cdotc(n_a_1, a, ONE, b, ONE)
            <%- elsif ta == :Complex and ka == :REAL64 -%>
               ASSERT(n_a_1 == n_b_1)
               ret = zdotc(n_a_1, a, ONE, b, ONE)
            <%- else -%>
               ret = dot_product(a, b)
            <%- end -%>
         <%- else -%>
            <%- t, k = promote(a, b) -%>
            call mul_(<%= converter(t) %>(a, kind=<%= k %>), <%= converter(t) %>(b, kind=<%= k %>), ret)
         <%- end -%>
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   ! compiler's implementation of scalar to vector/matrix multiplications might be fine
   ! scalar to vector: `*scal`
   ! scalar to matrix: ?

   <%- NUM_SCALAR_MUL_VEC_OR_MAT.each{|a, b| -%>
      pure subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a*b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   ! scalar to scalar multiplications and `Logical` multiplications were implemented only for consistency

   <%- (LOGICAL_SCALAR + LOGICAL_SCALAR_MUL_VEC_OR_MAT).each{|a, b| -%>
      pure subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a.and.b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   <%- NUM_SCALAR.each{|a, b| -%>
      pure subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a*b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   ! `mul<T><U>`

   <%- TYPES.each{|a, b| -%>
      function mul<%= a %><%= b %>(a, b) result(ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>:: ret
         call mul_(a, b, ret)
      end function mul<%= a %><%= b %>
   <%- } -%>
end module lapack_lib
