<%-
   require 'lapack_lib_util'
-%>
module lapack_lib
   <%= ::Fort::Type::USE_ISO_FORTRAN_ENV %>
   use, intrinsic:: iso_fortran_env, only: input_unit, output_unit, error_unit

   implicit none

   private
   public:: mul, mul_

   ! If you use LAPACK/BLAS with `ilp64` without `-fdefault-integer-8`, you should set `SIZE_KIND = INT64`
   Integer, parameter, public:: SIZE_KIND = kind(0)

   <%- TYPES.each{|a, b| -%>
      interface mul
         module procedure mul<%= a %><%= b %>
      end interface mul

      interface mul_
         module procedure mul_<%= a %><%= b %>
      end interface mul_
   <%- } -%>

contains


   <%- MAT_VEC_OR_MAT.each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         ret = matmul(a, b)
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   <%- VEC_VEC.each{|a, b| -%>
      <%- -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         ret = dot_product(a, b)
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   ! compiler's implementation of scalar to vector/matrix multiplications might be fine
   ! scalar to vector: `*scal`
   ! scalar to matrix: ?

   <%- NUM_SCALAR_MUL_VEC_OR_MAT.each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         ! <%= declare_sizes(a, b) %>
         <%= declare(a, b) %>, intent(out):: ret
         ret = a*b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   ! scalar to scalar multiplications and `Logical` multiplications were implemented only for consistency

   <%- (LOGICAL_SCALAR + LOGICAL_SCALAR_MUL_VEC_OR_MAT).each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a.and.b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>

   <%- NUM_SCALAR.each{|a, b| -%>
      subroutine mul_<%= a %><%= b %>(a, b, ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>, intent(out):: ret
         ret = a*b
      end subroutine mul_<%= a %><%= b %>
   <%- } -%>


   ! `mul<T><U>`

   <%- TYPES.each{|a, b| -%>
      function mul<%= a %><%= b %>(a, b) result(ret)
         <%= a.declare %>, intent(in):: a
         <%= b.declare %>, intent(in):: b
         <%= declare(a, b) %>:: ret
         call mul_(a, b, ret)
      end function mul<%= a %><%= b %>
   <%- } -%>

end module lapack_lib
